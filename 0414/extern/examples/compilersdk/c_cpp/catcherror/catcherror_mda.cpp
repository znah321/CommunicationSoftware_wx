/*==============================================================
 *
 * CATCHERROR_MDA.CPP
 * Sample driver code that uses the MATLAB Data API interface 
 * (introduced in R2018a) and MATLAB Data API to call a C++ 
 * shared library created using the MATLAB Compiler SDK.
 * Demonstrates redirection of standard output and error 
 * streams.
 * Refer to the MATLAB Compiler SDK documentation for more 
 * information.
 *
 * Copyright 2017-2019 The MathWorks, Inc.
 *
 *============================================================*/

// Include the header file required to use the generic
// interface for the C++ shared library generated by the
// MATLAB Compiler SDK.
#include "MatlabCppSharedLib.hpp"
#include <iostream>

namespace mc = matlab::cpplib;
namespace md = matlab::data;

std::u16string convertAsciiToUtf16(const std::string & asciiStr);

template <typename T>
void writeMatrix(std::ostream & ostr, md::TypedArray<T> matrix);

int mainFunc(std::shared_ptr<mc::MATLABApplication> app,
    const int argc, const char * argv[]);

namespace 
{
    // Define this in an anonymous namespace so that it doesn't fail
    // if someday std::u16stringbuf is defined to mean the same thing.
    using u16stringbuf = std::basic_stringbuf<char16_t>;
}

// The main routine. On the Mac, the main thread runs the system code, and
// user code must be processed by a secondary thread. On other platforms, 
// the main thread runs both the system code and the user code.
int main(const int argc, const char * argv[])
{
    int ret = 0;
    try {
        auto mode = mc::MATLABApplicationMode::IN_PROCESS;
        // We don't need a Java VM to run the code in this program.
        const std::string STR_OPTIONS = "-nojvm";
        const std::u16string U16STR_OPTIONS = convertAsciiToUtf16(STR_OPTIONS);
        std::vector<std::u16string> options = {U16STR_OPTIONS};
        auto matlabApplication = mc::initMATLABApplication(mode, options);
        ret = mc::runMain(mainFunc, std::move(matlabApplication), argc, argv);
    } catch(const std::exception & exc) {
        std::cerr << exc.what() << std::endl;
        return -1;
    }
    return ret;
}

int mainFunc(std::shared_ptr<mc::MATLABApplication> app,
    const int argc, const char * argv[])
{
    try {
        // The path to the CTF (library archive file) passed to 
        // initMATLABLibrary or initMATLABLibraryAsync may be either absolute
        // or relative. If it is relative, the following will be prepended
        // to it, in turn, in order to find the CTF:
        // - the directory named by the environment variable 
        // CPPSHARED_BASE_CTF_PATH, if defined
        // - the working directory
        // - the directory where the executable is located
        // - on Mac, the directory three levels above the directory
        // where the executable is located
        
        // If the CTF is not in one of these locations, do one of the following:
        // - copy the CTF
        // - move the CTF
        // - change the working directory ("cd") to the location of the CTF
        // - set the environment variable to the location of the CTF
        // - edit the code to change the path
        const std::string STR_CTF_NAME = "libcatcherror.ctf";
        const std::u16string U16STR_CTF_NAME = convertAsciiToUtf16(STR_CTF_NAME);
        
        auto lib = mc::initMATLABLibrary(app, U16STR_CTF_NAME);
        md::ArrayFactory factory;
        
        // Use these to collect output and error output.
        std::shared_ptr<u16stringbuf> outBuf = std::make_shared<u16stringbuf>();
        std::shared_ptr<u16stringbuf> errBuf = std::make_shared<u16stringbuf>();     
        
        const double VALID_VALUE_FOR_REALACOS = 0.1625;
        const double INVALID_VALUE_FOR_REALACOS = 17;
        
        auto validValueForRealacos = factory.createScalar(VALID_VALUE_FOR_REALACOS);
        auto invalidValueForRealacos = factory.createScalar(INVALID_VALUE_FOR_REALACOS);
        
        std::vector<md::Array> outputFromRealacos;
        std::vector<md::Array> vecWithValidValueForRealacos{validValueForRealacos};
        std::vector<md::Array> vecWithInvalidValueForRealacos{invalidValueForRealacos};
        try {
            outputFromRealacos = lib->feval("realacos", 1, 
                vecWithValidValueForRealacos, outBuf, errBuf);
        } catch(const std::exception &) {
            throw;
        }

        try {
            outputFromRealacos = lib->feval("realacos", 1, 
                vecWithInvalidValueForRealacos, outBuf, errBuf);
        } catch(const std::exception &) {
            // Swallow the exception now that we've stored the error.
        }
        std::cout << "******** Start MATLAB output *********" << std::endl
            << mc::convertUTF16StringToUTF8String(outBuf.get()->str()) << std::endl
            << "******** End MATLAB output ***********" << std::endl << std::endl;
            
        std::cout << "******** Start MATLAB error output *******" << std::endl
            << mc::convertUTF16StringToUTF8String(errBuf.get()->str()) << std::endl
            << "******** End MATLAB error output *********" << std::endl << std::endl;
            
    } catch(std::exception & exc) {
        std::cerr << exc.what() << std::endl;
    }
        
    return 0;
}

// Since ASCII is a subset of UTF-8, the function 
// mc::convertUTF8StringToUTF16String() can also
// be used to convert an ASCII string to a UTF-16 string.
// However, this technique is faster, though it should only 
// be used if the contents of the string are known to be ASCII.
std::u16string convertAsciiToUtf16(const std::string & asciiStr)
{
    return std::u16string(asciiStr.cbegin(), asciiStr.cend());
}

template <typename T>
void writeMatrix(std::ostream & ostr, md::TypedArray<T> matrix)
{
    md::ArrayDimensions dims = matrix.getDimensions();
    if (dims.size() != 2)
    {
        std::ostringstream ostrstrm;
        ostrstrm << "Number of dimensions passed to writeMatrix must be 2; "
            << "actual number: " << dims.size();
        throw std::runtime_error(ostrstrm.str());
    }

    for (size_t row = 0; row < dims[0]; ++row)
    {
        for (size_t col = 0; col < dims[1]; ++col)
        {
            ostr << matrix[row][col] << " ";
        }
        ostr << std::endl;
    }
    ostr << std::endl;
}

