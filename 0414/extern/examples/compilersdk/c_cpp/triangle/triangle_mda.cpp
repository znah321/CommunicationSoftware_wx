/*==============================================================
 *
 * TRIANGLE_MDA.CPP
 * Sample driver code that uses the MATLAB Data API interface 
 * (introduced in R2018a) to call a C++ shared library created 
 * using the MATLAB Compiler SDK.
 * Demonstrates graphics (draws a figure) and passing scalar
 * numbers.
 * Refer to the MATLAB Compiler SDK documentation for more 
 * information.
 *
 * Copyright 2017-2019 The MathWorks, Inc.
 *
 *============================================================*/

// Include the header file required to use the generic
// interface for the C++ shared library generated by the
// MATLAB Compiler SDK.
#include "MatlabCppSharedLib.hpp"
#include <iomanip>
#include <iostream>

namespace mc = matlab::cpplib;
namespace md = matlab::data;

const int DEFAULT_NUMBER_OF_POINTS = 1000;

std::u16string convertAsciiToUtf16(const std::string & asciiStr);

void usage(std::ostream & ostr, const int argc, const char * argv[]);

bool parseBoolArg(int index, const char * argv[]);

void parseArgv(const int argc, const char * argv[], size_t & numPoints, 
    bool & doDraw, bool & doList);

template <typename T>
void printCoordinates(std::ostream & ostr, 
    const md::TypedArray<T> & xCoordinates, 
    const md::TypedArray<T> & yCoordinates,
    size_t numPoints);

int mainFunc(std::shared_ptr<mc::MATLABApplication> app,
    const int argc, const char * argv[]);
    
// The main routine. On the Mac, the main thread runs the system code, and
// user code must be processed by a secondary thread. On other platforms, 
// the main thread runs both the system code and the user code.
int main(const int argc, const char * argv[])
{
    int ret = 0;
    try {
        auto mode = mc::MATLABApplicationMode::IN_PROCESS;
        std::vector<std::u16string> options = {};
        auto matlabApplication = mc::initMATLABApplication(mode, options);
        ret = mc::runMain(mainFunc, std::move(matlabApplication),  argc, argv);
    } catch(const std::exception & exc) {
        std::cerr << exc.what() << std::endl;
        return -1;
    }
    return ret;
}

int mainFunc(std::shared_ptr<mc::MATLABApplication> app,
    const int argc, const char * argv[])
{
    try {
        const std::string STR_CTF_NAME = "libtriangle.ctf";
        const std::u16string U16STR_CTF_NAME = convertAsciiToUtf16(STR_CTF_NAME);
        
        size_t numPoints(DEFAULT_NUMBER_OF_POINTS);
        bool doDraw(true);
        bool doList(false);
        parseArgv(argc, argv, numPoints, doDraw, doList);
        
        // The path to the CTF (library archive file) passed to 
        // initMATLABLibrary or initMATLABLibraryAsync may be either absolute
        // or relative. If it is relative, the following will be prepended
        // to it, in turn, in order to find the CTF:
        // - the directory named by the environment variable 
        // CPPSHARED_BASE_CTF_PATH, if defined
        // - the working directory
        // - the directory where the executable is located
        // - on Mac, the directory three levels above the directory
        // where the executable is located
        
        // If the CTF is not in one of these locations, do one of the following:
        // - copy the CTF
        // - move the CTF
        // - change the working directory ("cd") to the location of the CTF
        // - set the environment variable to the location of the CTF
        // - edit the code to change the path
        auto lib = mc::initMATLABLibrary(app, U16STR_CTF_NAME);
        md::ArrayFactory factory;

        auto numPointsAsArray = factory.createScalar(numPoints);
        auto doDrawAsArray = factory.createScalar(doDraw); // create a logical scalar

        std::vector<md::Array> inputs{numPointsAsArray, doDrawAsArray};
        // The Sierpinski function returns the X and Y coordinates of the points
        // in the triangle. If doDraw is true, it also draws the figure.
        auto coordinates = lib->feval("sierpinski", 2, inputs);
        // coordinates[0] corresponds to the X coordinates of the points, and
        // coordinates[1] corresponds to the Y coordinates.
        if (doList)
        {
            printCoordinates<double>(std::cout, coordinates[0], coordinates[1], numPoints);
        }
        if (doDraw)
        {
            // Will wait until the user closes the figure.
            lib->waitForFiguresToClose();
        }
    } catch(std::exception & exc) {
        std::cerr << exc.what() << std::endl;
        return -1;
    }
    return 0;
}

std::u16string convertAsciiToUtf16(const std::string & asciiStr)
{
    return std::u16string(asciiStr.cbegin(), asciiStr.cend());
}

void usage(std::ostream & ostr, const int argc, const char * argv[])
{
    const char * const DEFAULT_PROGRAM_NAME = "triangle_generic";
    const char * program_name = (argc > 0) ? argv[0] : DEFAULT_PROGRAM_NAME;
    std::string pname_as_str(program_name);
    auto last_dir_sep = pname_as_str.find_last_of("/\\");
    std::string pname_to_show = ((last_dir_sep == std::string::npos) 
            ? pname_as_str 
            : pname_as_str.substr(last_dir_sep+1));
    ostr << "Usage: " 
        << pname_to_show
        << " [points; default: " << DEFAULT_NUMBER_OF_POINTS << "]"
        << " [0|1; 1 = draw (default: 1)]"
        << " [0|1; 1 = list (default: 0)]"
        << std::endl
        << "Example: " << pname_to_show << " 500 0 1" << std::endl;
}

// Take an argument that should be "0" or "1" and convert it to "false" or "true",
// respectively.
bool parseBoolArg(int index, const char * argv[])
{
    if (!argv[index])
    {
        throw std::runtime_error("Null argument.");
    }
    else if (strlen(argv[index]) != 1 || (argv[index][0] != '0' && argv[index][0] != '1'))
    {
        std::ostringstream ostr;
        ostr << "Argument " << index << " ('" << argv[index] << "') should be 0 or 1.";
        throw std::runtime_error(ostr.str());
    }
    return (argv[index][0] == '1');
}

void parseArgv(const int argc, const char * argv[], size_t & numPoints, 
    bool & doDraw, bool & doList)
{
    try {
        // Validate the number of inputs
        if (argc < 1 || argc > 4)
        {
            std::ostringstream ostr;
            ostr << "Expecting 0 or 1 input(s). Found " << argc - 1 << ".";
            throw std::runtime_error(ostr.str());
        }

        // If we have an input, try to convert the input string to an integer, 
        // which should be positive.
        if (argc > 1)
        {
            int numPointsAsInt = 0;
            try {
                numPointsAsInt = std::stoi(argv[1]);
            }
            catch (const std::exception &) {
                std::ostringstream ostr;
                ostr << "Argument 1 ('" << argv[1] << "') is not an integer.";
                throw std::runtime_error(ostr.str());
            }
            if (numPointsAsInt < 1)
            {
                std::ostringstream ostr;
                ostr << "Argument 1 ('" << argv[1] << "') is not a positive integer.";
                throw std::runtime_error(ostr.str());
            }
            else
            {
                numPoints = static_cast<size_t>(numPointsAsInt);
            }
        }

        if (argc > 2)
        {
            doDraw = parseBoolArg(2, argv);
        }

        if (argc > 3)
        {
            doList = parseBoolArg(3, argv);
        }

    } catch(const std::exception &) {
        usage(std::cerr, argc, argv);
        throw;
    }
}

template <typename T>
void printCoordinates(std::ostream & ostr, 
    const md::TypedArray<T> & xCoordinates, 
    const md::TypedArray<T> & yCoordinates,
    size_t numPoints)
{
    for (size_t index = 0; index < numPoints; ++index)
    {
        ostr << "Point " << index << ": (" << xCoordinates[0][index] << ", "
            << yCoordinates[0][index] << ")" << std::endl;
    }
}

