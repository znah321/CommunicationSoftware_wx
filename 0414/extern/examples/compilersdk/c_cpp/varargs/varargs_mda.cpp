/*==============================================================
 *
 * VARARGS_MDA.CPP
 * Sample driver code that uses the MATLAB Data API interface 
 * to call a C++ shared library created using the MATLAB 
 * Compiler SDK.
 * Demonstrates how to handle a variable number of inputs and 
 * outputs. Refer to the MATLAB Compiler SDK documentation for 
 * more information.
 *
 * Copyright 2017-2019 The MathWorks, Inc.
 *
 *============================================================*/

// Include the header file required to use the MATLAB Data API
// interface for the C++ shared library generated by the
// MATLAB Compiler SDK.
#include "MatlabCppSharedLib.hpp"
#include <iomanip>
#include <iostream>

namespace mc = matlab::cpplib;
namespace md = matlab::data;

std::u16string convertAsciiToUtf16(const std::string & asciiStr);

void usage(std::ostream & ostr, const int argc, const char * argv[]);

std::vector<std::u16string> parseArgv(const int argc, const char * argv[], size_t & numOutputs);

int mainFunc(std::shared_ptr<mc::MATLABApplication> app,
    const int argc, const char * argv[]);

// The main routine. On the Mac, the main thread runs the system code, and
// user code must be processed by a secondary thread. On other platforms, 
// the main thread runs both the system code and the user code.
int main(const int argc, const char * argv[])
{
    int ret = 0;
    try {
        auto mode = mc::MATLABApplicationMode::IN_PROCESS;
        std::vector<std::u16string> options = {};
        auto matlabApplication = mc::initMATLABApplication(mode, options);
        ret = mc::runMain(mainFunc, std::move(matlabApplication),  argc, argv);
    } catch(const std::exception & exc) {
        std::cerr << exc.what() << std::endl;
        return -1;
    }
    return ret;
}

int mainFunc(std::shared_ptr<mc::MATLABApplication> app,
    const int argc, const char * argv[])
{
    try {
        // The path to the CTF (library archive file) passed to 
        // initMATLABLibrary or initMATLABLibraryAsync may be either absolute
        // or relative. If it is relative, the following will be prepended
        // to it, in turn, in order to find the CTF:
        // - the directory named by the environment variable 
        // CPPSHARED_BASE_CTF_PATH, if defined
        // - the working directory
        // - the directory where the executable is located
        // - on Mac, the directory three levels above the directory
        // where the executable is located
        
        // If the CTF is not in one of these locations, do one of the following:
        // - copy the CTF
        // - move the CTF
        // - change the working directory ("cd") to the location of the CTF
        // - set the environment variable to the location of the CTF
        // - edit the code to change the path
        const std::string STR_CTF_NAME = "libvarargs.ctf";
        const std::u16string U16STR_CTF_NAME = convertAsciiToUtf16(STR_CTF_NAME);
        
        auto lib = mc::initMATLABLibrary(app, U16STR_CTF_NAME);
        md::ArrayFactory factory;
        
        size_t numOutputs(0);
        std::vector<std::u16string> inputStrings = parseArgv(argc, argv, numOutputs);
        std::vector<md::Array> inputsAsUntypedArrays(inputStrings.size());
        std::transform(inputStrings.cbegin(), inputStrings.cend(), 
            inputsAsUntypedArrays.begin(), 
            [&factory](std::u16string str) {return factory.createCharArray(str);});
        std::cout << "Calling varargs..." << std::endl;
        auto output = lib->feval("varargs", numOutputs, inputsAsUntypedArrays);
        size_t len = output.size();
        for (size_t index = 0; index < len; ++index)
        {
            std::cout << "output[" << index << "]: " << (int) output[index][0] << std::endl;
        }
        std::cout << "Calling noargs..." << std::endl;
        std::vector<md::Array> dummy_output = lib->feval("noargs", 0, 
            std::vector<md::Array>());
        std::cout << "number of outputs from noargs: " << dummy_output.size() << std::endl;
    } catch(const std::exception & exc) {
        std::cerr << exc.what() << std::endl;
        return -1;
    }
    return 0;
}

std::u16string convertAsciiToUtf16(const std::string & asciiStr)
{
    return std::u16string(asciiStr.cbegin(), asciiStr.cend());
}

void usage(std::ostream & ostr, const int argc, const char * argv[])
{
    const char * const DEFAULT_PROGRAM_NAME = "variable_arg_generic";
    const char * program_name = (argc > 0) ? argv[0] : DEFAULT_PROGRAM_NAME;
    std::string pname_as_str(program_name);
    auto last_dir_sep = pname_as_str.find_last_of("/\\");
    std::string pname_to_show = ((last_dir_sep == std::string::npos) 
            ? pname_as_str 
            : pname_as_str.substr(last_dir_sep+1));
    ostr << "Usage: " << pname_to_show
        << " number_of_desired_outputs (must be nonnegative) "
        << " [input arg]*"
        << std::endl
        << "Example: " << pname_to_show << " 5 a b c" << std::endl;
}

// Returns a vector containing the input arguments (not including the argument
// that indicates the desired number of outputs, which will be stored in numOutputs).
std::vector<std::u16string> parseArgv(const int argc, const char * argv[], size_t & numOutputs)
{
    std::vector<std::u16string> inputStrings;
    try {
        // Validate the number of inputs
        if (argc < 2)
        {
            std::ostringstream ostr;
            ostr << "Expecting number of desired output arguments, "
                "followed by 0 or more input arguments.";
            throw std::runtime_error(ostr.str());
        }

        // If we have an input, try to convert the input string to an integer, 
        // which should be nonnegative.
        if (argc > 1)
        {
            int numOutputsAsInt = 0;
            try {
                numOutputsAsInt = std::stoi(argv[1]);
            }
            catch (const std::exception &) {
                std::ostringstream ostr;
                ostr << "Argument 1 ('" << argv[1] << "') is not a nonnegative integer.";
                throw std::runtime_error(ostr.str());
            }
            if (numOutputsAsInt < 0)
            {
                std::ostringstream ostr;
                ostr << "Argument 1 ('" << argv[1] << "') is not a nonnegative integer.";
                throw std::runtime_error(ostr.str());
            }
            else
            {
                numOutputs = static_cast<size_t>(numOutputsAsInt);
            }
        }

        if (argc > 2)
        {
            for (int index = 2; index < argc; ++index)
            {
                inputStrings.push_back(mc::convertUTF8StringToUTF16String(argv[index]));
            }
        }
    } catch(const std::exception &) {
        usage(std::cerr, argc, argv);
        throw;
    }
    return inputStrings;
}

